<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test</title>

    <style>
        * {
            border: none;
            margin: 0;
            padding: 0;
        }
        canvas { margin: auto; }
    </style>
</head>
<body>
    <script type='module'>

        import * as THREE from 'https://cdn.skypack.dev/three@0.133.1';

        // simulation params
        const attractionMagnitude = 0.01; // this is a distance
        const repulsionMagnitude = attractionMagnitude * 2.5;
        const dampening = 0.75;
        const dt = 0.5;
        const noise = 0.25;
        const numPoints = 300;
        const direct = true;
        const iterations = 1000; // only in indirect mode

        // rendering constants
        const numCirclePoints = 60;
        const radius = 1.0;



        // modify document style
        if (direct) {
            document.body.style.overflow = 'hidden';
        }

        // init renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        if (direct) {
            const sz = window.innerWidth > window.innerHeight ? window.innerHeight : window.innerWidth;
            renderer.setSize(sz, sz);
            document.body.append(renderer.domElement);
        } else {
            renderer.setSize(512, 512);
        }
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('white');
        const camera = new THREE.OrthographicCamera(-1.05, 1.05, 1.05, -1.05, 0.1, 10);

        // init mesh - points are ordered in order of insertion, not in any render/connection order
        let points = [];
        const pushPoint = (x, y, idx = null) => {
            if (idx === null) {
                idx = Math.max(points.length - 1, 0);
            }
            let pt = {
                position: new THREE.Vector2(x, y),
                velocity: new THREE.Vector2(0, 0),
                accel: new THREE.Vector2(0, 0),
                n: Math.random() * 2 - 1, // -1..1
                prev: idx,
                next: points.length > 0 ? points[idx].next : idx
            };
            if (points.length > 0) {
                points[pt.prev].next = points.length;
                points[pt.next].prev = points.length;
            }
            points.push(pt);
        };
        let circlePoints = [];
        for (let i = 0; i < numCirclePoints; ++i) {
            let angle = i * Math.PI * 2 / numCirclePoints;
            let p = new THREE.Vector2(Math.cos(angle), Math.sin(angle)).multiplyScalar(radius);
            circlePoints.push(new THREE.Vector3(p.x, p.y, -1));
        }
        for (let i = 0; i < numPoints; ++i) {
            let angle = i * Math.PI * 2 / numPoints;
            let p = new THREE.Vector2(Math.cos(angle), Math.sin(angle)).multiplyScalar(radius);
            pushPoint(p.x * 0.9, p.y * 0.9);
        }
        circlePoints.push(circlePoints[0].clone());
        const staticLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints(circlePoints), new THREE.LineBasicMaterial({ color: 'red' }));
        scene.add(staticLine);
        
        // function to add a node between two random neighbours
        const addNode = () => {
            let idx = Math.floor(Math.random() * points.length);
            let point = points[idx];
            let next = points[point.next];
            let p = point.position.clone().lerp(next.position, 0.5);
            pushPoint(p.x, p.y, idx);
        };

        // refresh mesh rendering from points
        const geometry = new THREE.BufferGeometry();
        const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 'black' }));
        scene.add(line);
        const refresh = () => {
            let vertices = [];
            let current = 0;
            do {
                let point = points[current];
                vertices.push(new THREE.Vector3(point.position.x, point.position.y, -1));
                current = point.next;
            } while (current != 0);
            vertices.push(new THREE.Vector3(points[0].position.x, points[0].position.y, -1));
            geometry.setFromPoints(vertices);
            renderer.render(scene, camera);
            if (!direct) {
                const src = renderer.domElement.toDataURL();
                const img = document.createElement('img');
                img.src = src;
                img.style.width = '256px';
                img.style.height = '256px';
                document.body.append(img);
            }
        };
        refresh();

        // update nodes based on distance
        const updateDistances = () => {

            // attract towards neighbours + push away from others
            for (let i = 0; i < points.length; ++i) {
                let point = points[i];
                point.accel.set(0, 0);
                point.velocity.multiplyScalar(dampening);
                if (point.position.length() >= radius * 0.9) {
                    let d = (radius * 0.9 - point.position.length()) / radius;
                    point.accel.add(point.position.clone().multiplyScalar(-d * d * 0.5));
                }
                // iterate over other points
                for (let j = 0; j < points.length; ++j) {
                    if (j == i) continue;
                    let other = points[j];
                    let towards = new THREE.Vector2().subVectors(other.position, point.position);
                    let d = towards.length();
                    d *= (1 + point.n * noise);
                    if (j == point.prev || j == point.next) {
                        // neighbour
                        point.accel.add(towards.normalize().multiplyScalar(d - attractionMagnitude)); // negative if close to target, positive if far from target
                    } else {
                        // other point
                        if (d < repulsionMagnitude) {
                            let force = (repulsionMagnitude - d);
                            point.accel.add(towards.normalize().multiplyScalar(-force));
                        }
                    }
                }
            }

            // update point positions
            for (let i = 0; i < points.length; ++i) {
                let point = points[i];
                point.accel.add(point.velocity.clone().multiplyScalar(-dampening));
                point.velocity.add(point.accel.clone().multiplyScalar(dt));
                point.position.add(point.velocity.clone().multiplyScalar(dt)).clampLength(0, radius);
            }
        };

        // bind events
        if (direct) {
            document.addEventListener('keypress', (e) => {
                e = e || window.event;
                if (e.key == ' ') {
                    for(let i = 0; i < 20; ++i) addNode();
                }
            });
            document.addEventListener('click', () => {
                for(let i = 0; i < 20; ++i) addNode();
            });
        }

        // direct update loop
        const update = () => {

            updateDistances();
            refresh();

            requestAnimationFrame(update);
        };

        // results update loop
        let t = 0;
        const results = () => {
            ++t;

            for (let j = 0; j < 5; ++j) {
                for (let mT = t + 80; t < mT; ++t) {
                    updateDistances();
                }
                for(let i = 0; i < 50; ++i) addNode();
            }
            refresh();

            if (t < iterations) {
                requestAnimationFrame(results);
            } else {
                document.body.append(document.createTextNode('100% done.'));
            }
        }

        if (direct) update();
        else results();

    </script>
</body>
</html>