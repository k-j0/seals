<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test</title>

    <style>
        * {
            border: none;
            margin: 0;
            padding: 0;
            font-family: sans-serif;
        }
        canvas { margin: auto; }
        span {
            display: block;
            position: fixed;
            margin: 20px;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <script type='module'>

        import * as THREE from 'https://cdn.skypack.dev/three@0.133.1';

        // simulation params
        const attractionMagnitude = 0.01; // this is a distance
        const repulsionMagnitude = attractionMagnitude * 2.5;
        const dampening = 0.75;
        const dt = 0.5;
        const noise = 0.25;
        const numPoints = 300;
        const direct = true;
        const iterations = 1000; // only in indirect mode
        const gridResolution = Math.ceil(0.25 / Math.max(repulsionMagnitude, attractionMagnitude));
        console.log('Repulsion magnitude:', repulsionMagnitude, '| Grid cell size:', 0.5/gridResolution, '| Grid resolution:', gridResolution);

        // rendering constants
        const numCirclePoints = 60;
        const radius = 1.0;


        let grid = [];
        let points = [];


        // modify document style
        if (direct) {
            document.body.style.overflow = 'hidden';
        }
        let stats = document.createElement('span');
        document.body.append(stats);
        const setStats = (str) => {
            stats.innerHTML = str;
        };

        // init renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        if (direct) {
            const sz = window.innerWidth > window.innerHeight ? window.innerHeight : window.innerWidth;
            renderer.setSize(sz, sz);
            document.body.append(renderer.domElement);
        } else {
            renderer.setSize(512, 512);
        }
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('white');
        const camera = new THREE.OrthographicCamera(-1.05, 1.05, 1.05, -1.05, 0.1, 10);

        // spatial acceleration data structure
        for (let i = 0; i < gridResolution; ++i) {
            grid.push([]);
            for (let j = 0; j < gridResolution; ++j) {
                grid[i].push([]);
            }
        }
        const clearGrid = () => {
            for (let i = 0; i < gridResolution; ++i)
            for (let j = 0; j < gridResolution; ++j) {
                grid[i][j] = [];
            }
        };
        const assignGridPt = (idx) => {
            let x = parseInt((points[idx].position.x + 1) * gridResolution * 0.5);
            let y = parseInt((points[idx].position.y + 1) * gridResolution * 0.5);
            grid[x][y].push(idx);
        };
        const gridNeighbours = (idx) => {
            let subX = parseInt((points[idx].position.x + 1) * gridResolution);
            let subY = parseInt((points[idx].position.y + 1) * gridResolution);
            let x = parseInt(subX * 0.5);
            let y = parseInt(subY * 0.5);
            let lr = subX % 2 == 0 ? x - 1 : x + 1;
            let tb = subY % 2 == 0 ? y - 1 : y + 1;
            
            let c = 0;
            let neighbours = grid[x][y];
            if (lr >= 0 && lr < gridResolution) {
                neighbours = neighbours.concat(grid[lr][y]);
                ++c;
            }
            if (tb >= 0 && tb < gridResolution) {
                neighbours = neighbours.concat(grid[x][tb]);
                ++c;
            }
            if (c >= 2) {
                neighbours = neighbours.concat(grid[lr][tb]);
            }
            return neighbours;
        };

        // init mesh - points are ordered in order of insertion, not in any render/connection order
        const pushPoint = (x, y, idx = null) => {
            if (idx === null) {
                idx = Math.max(points.length - 1, 0);
            }
            let pt = {
                position: new THREE.Vector2(x, y),
                velocity: new THREE.Vector2(0, 0),
                accel: new THREE.Vector2(0, 0),
                n: Math.random() * 2 - 1, // -1..1
                prev: idx,
                next: points.length > 0 ? points[idx].next : idx
            };
            if (points.length > 0) {
                points[pt.prev].next = points.length;
                points[pt.next].prev = points.length;
            }
            points.push(pt);
            assignGridPt(points.length - 1);
        };
        let circlePoints = [];
        for (let i = 0; i < numCirclePoints; ++i) {
            let angle = i * Math.PI * 2 / numCirclePoints;
            let p = new THREE.Vector2(Math.cos(angle), Math.sin(angle)).multiplyScalar(radius);
            circlePoints.push(new THREE.Vector3(p.x, p.y, -1));
        }
        for (let i = 0; i < numPoints; ++i) {
            let angle = i * Math.PI * 2 / numPoints;
            let p = new THREE.Vector2(Math.cos(angle), Math.sin(angle)).multiplyScalar(radius);
            pushPoint(p.x * 0.9, p.y * 0.9);
        }
        circlePoints.push(circlePoints[0].clone());
        const staticLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints(circlePoints), new THREE.LineBasicMaterial({ color: 'red' }));
        scene.add(staticLine);
        
        // function to add a node between two random neighbours
        const addNode = () => {
            let idx = Math.floor(Math.random() * points.length);
            let point = points[idx];
            let next = points[point.next];
            let p = point.position.clone().lerp(next.position, 0.5);
            pushPoint(p.x, p.y, idx);
        };

        // refresh mesh rendering from points
        const geometry = new THREE.BufferGeometry();
        const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 'black' }));
        scene.add(line);
        const refresh = () => {
            let vertices = [];
            let current = 0;
            do {
                let point = points[current];
                vertices.push(new THREE.Vector3(point.position.x, point.position.y, -1));
                current = point.next;
            } while (current != 0);
            vertices.push(new THREE.Vector3(points[0].position.x, points[0].position.y, -1));
            geometry.setFromPoints(vertices);
            renderer.render(scene, camera);
            if (!direct) {
                const src = renderer.domElement.toDataURL();
                const img = document.createElement('img');
                img.src = src;
                img.style.width = '256px';
                img.style.height = '256px';
                document.body.append(img);
            }
        };
        refresh();

        // update nodes based on distance
        const updateDistances = () => {
            let startTime = performance.now();

            // attract towards neighbours + push away from others
            for (let i = 0; i < points.length; ++i) {
                let point = points[i];
                point.accel.set(0, 0);
                point.velocity.multiplyScalar(dampening);
                if (point.position.length() >= radius * 0.9) {
                    let d = (radius * 0.9 - point.position.length()) / radius;
                    point.accel.add(point.position.clone().multiplyScalar(-d * d * 0.5));
                }
                // iterate over other points (within grid)
                let others = gridNeighbours(i);
                for (let gridJ = 0; gridJ < others.length; ++gridJ) {
                    let j = others[gridJ];
                    if (j == i) continue;
                    let other = points[j];
                    let towards = new THREE.Vector2().subVectors(other.position, point.position);
                    let d = towards.length();
                    d *= (1 + point.n * noise);
                    if (j == point.prev || j == point.next) {
                        // neighbour
                        point.accel.add(towards.normalize().multiplyScalar(d - attractionMagnitude)); // negative if close to target, positive if far from target
                    } else {
                        // other point
                        if (d < repulsionMagnitude) {
                            let force = (repulsionMagnitude - d);
                            point.accel.add(towards.normalize().multiplyScalar(-force));
                        }
                    }
                }
            }

            // update point positions
            clearGrid();
            for (let i = 0; i < points.length; ++i) {
                let point = points[i];
                point.accel.add(point.velocity.clone().multiplyScalar(-dampening));
                point.velocity.add(point.accel.clone().multiplyScalar(dt));
                point.position.add(point.velocity.clone().multiplyScalar(dt)).clampLength(0, radius);
                assignGridPt(i);
            }

            return performance.now() - startTime;
        };

        // bind events
        if (direct) {
            document.addEventListener('keypress', (e) => {
                e = e || window.event;
                if (e.key == ' ') {
                    for(let i = 0; i < 20; ++i) addNode();
                }
            });
            document.addEventListener('click', () => {
                for(let i = 0; i < 20; ++i) addNode();
            });
        }

        // direct update loop
        const update = () => {

            let updateTime = updateDistances();
            refresh();

            setStats('frame time: ' + (updateTime * 0.001).toFixed(2) + 's | points: ' + points.length);

            requestAnimationFrame(update);
        };

        // results update loop
        let t = 0;
        const results = () => {
            ++t;

            for (let j = 0; j < 5; ++j) {
                for (let mT = t + 80; t < mT; ++t) {
                    updateDistances();
                }
                for(let i = 0; i < 50; ++i) addNode();
            }
            refresh();

            if (t < iterations) {
                setStats(parseInt(t / iterations * 100) + '%');
                requestAnimationFrame(results);
            } else {
                setStats('Done.');
            }
        }

        if (direct) update();
        else results();

    </script>
</body>
</html>